//快速排序
快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，
通常称其为分治法(Divide-and-ConquerMethod)。

该方法的基本思想是：

1．先从数列中取出一个数作为基准数。
2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
3．再对左右区间重复第二步，直到各区间只有一个数。

虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。
因此我的对快速排序作了进一步的说明：挖坑填数+分治法

对挖坑填数进行总结

1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。

2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。

3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。

4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。


//挖坑填数部分代码
int AdjustArray(int s[], int l, int r)
{
	int i = l, j = r;
	int x = s[1];
	while(i < j)
	{
		while(i < j && s[j] >= x)
		j--;
		if(i < j)
		{
			s[i] = s[j];
			i++;
		}
		while(i < j && s[i] < x)
			i++;
		if(i < j)
		{
			s[j] = s[i];
			j--;
		}
	}
	//最后一定有i==j
	s[i] = x;
	return i
}


//分治法部分代码
void quick_sort1(int s[], int l, int r)
{
	if(l < r)
	{
		int i = AdjustArray(s, l, r);
		quick_sort1(s, l, i-1);
		quick_sort1(s, i+1, r);
	}
}





//将两部分代码综合并优化代码
void quick_sort(int s[], int l, int r)
{
	int i = l, j = r;
	int x = s[1];
	while(i < j)
	{
		while(i < j && s[j] >= x)
			j--;
		if(i < j)
		{
			s[i] = s[j];
			i++;
		}

		while(i < j && s[i] < x)
			i++;
		if(i < j)
		{
			s[j] = s[i];
			j--;
		}
	}
	s[i] = x;
	quick_sort(s, l, i-1);
	quick_sort(s, i+1, r);
}

	快速排序还有很多改进版本，如随机选择基准数，区间内数据较少时直接用
另的方法排序以减小递归深度。有兴趣的筒子可以再深入的研究下。

 

注1，有的书上是以中间的数作为基准数的，要实现这个方便非常方便，直接将
中间的数和第一个数进行交换就可以了