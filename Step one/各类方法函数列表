String 函数列表

    函数名      描述
    begin      得到指向字符串开头的Iterator
    end      得到指向字符串结尾的Iterator
    rbegin      得到指向反向字符串开头的Iterator
    rend      得到指向反向字符串结尾的Iterator
    size      得到字符串的大小
    length      和size函数功能相同
    max_size      字符串可能的最大大小
    capacity      在不重新分配内存的情况下，字符串可能的大小
    empty      判断是否为空
    operator[]      取第几个元素，相当于数组
    c_str      取得C风格的const char* 字符串，一定有'\0'结尾
    data      取得字符串内容地址
    operator=      赋值操作符
    reserve      预留空间
    swap      交换函数
    insert      插入字符
    append      追加字符串，注意与push_back区别
    push_back      追加字符
    operator+=      += 操作符
    erase      删除字符串  str.erase(str.begin())参数要为迭代器类型
    clear      清空字符容器中所有内容
    resize      重新分配空间
    assign      和赋值操作符一样，string& assign ( const string& str, size_t pos, size_t n );将str的内容从位置pos起的n个字符作为原字串的新内容赋给原字串

    replace      替代
    copy      字符串到空间
    find      查找
    rfind      反向查找
    find_first_of      查找包含子串中的任何字符，返回第一个位置
    find_first_not_of      查找不包含子串中的任何字符，返回第一个位置
    find_last_of      查找包含子串中的任何字符，返回最后一个位置
    find_last_not_of      查找不包含子串中的任何字符，返回最后一个位置
    substr      得到字串
    compare      比较字符串
    operator+      字符串链接
    operator==      判断是否相等
    operator!=      判断是否不等于
    operator<      判断是否小于
    operator>>      从输入流中读入字符串
    operator<<      字符串写入


—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


Vector 函数列表

    push_back   在数组的最后添加一个数据
    pop_back    去掉数组的最后一个数据 
    at                得到编号位置的数据,区别于[],at自带越界检查
    begin           得到数组头的指针
    end             得到数组的最后一个单元+1的指针
    front        得到数组头的引用
    back            得到数组的最后一个单元的引用
    max_size     得到vector最大可以是多大
    capacity       当前vector分配的大小
    size           当前使用数据的大小
    resize         改变当前使用数据的大小，如果它比当前使用的大，者填充默认值
    reserve      改变当前vecotr所分配空间的大小
    erase         删除指针指向的数据项
    clear          清空当前的vector
    rbegin        将vector反转后的开始指针返回(其实就是原来的end-1)
    rend          将vector反转构的结束指针返回(其实就是原来的begin-1)
    empty        判断vector是否为空
    swap         与另一个vector交换数据
    clear()         移除容器中所有数据。
    empty()         判断容器是否为空。
    erase(pos)        删除pos位置的数据
    erase(beg,end) 删除[beg,end)区间的数据
    front()         传回第一个数据。
    insert(pos,elem)  在pos位置插入一个elem拷贝
    pop_back()     删除最后一个数据。
    push_back(elem) 在尾部加入一个数据。
    resize(num)     重新设置该容器的大小
    size()         回容器中实际数据的个数。
    begin()           返回指向容器第一个元素的迭代器
    end()             返回指向容器最后一个元素的迭代器
    assign(beg,end)：将[beg; end)区间中的数据赋值给c。
    assign(n,elem)：将n个elem的拷贝赋值给c。 
    at(idx)：传回索引idx所指的数据，如果idx越界，抛出out_of_range。 
    back()：传回最后一个数据，不检查这个数据是否存在。
    front()：传回地一个数据。 
    get_allocator：使用构造函数返回一个拷贝。 
    rbegin()：传回一个逆向队列的第一个数据。 
    rend()：传回一个逆向队列的最后一个数据的下一个位置。 
    ~ vector <Elem>()：销毁所有数据，释放内存


———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
___________________________________________________________________________________________________________________



set集合容器：
调用头文件：
#include<set>
using namespace std;
详细用法(部分)：
set<int> t      ------      定义一个int类型的容器，注意set里的每个元素只会出现1次
t.insert(k)      ------      插入元素k，多次插入同一个元素后面无效
t.count(k)      ------      判断元素k是否在容器内
t.erase(k)      ------      删除元素k，若不存在则删除无效
t.clear()      ------      清空容器
t.size()      ------      返回容器现有元素个数
t.empty()      ------      判断容器是否为空

想遍历set里的元素或进行进一步修改，必须定义对应迭代器，以下三种定义方法（迭代器类似于指针）
set<int>::iterator it      ------      定义正向迭代器
set<int>::reverse_iterator rit;      ------      定义反向迭代器
auto it = t.begin();      ------      因为t.begin()返回正向迭代器，所以it自动被定义为正向迭代器，可适应其他所有操作
以下需要迭代器的操作：
t.begin()      ------      返回set中第一个元素，类型为正向迭代器
t.rbegin()      ------      返回set中最后一个元素，类型为反向迭代器
t.end()      ------      返回set中最后一个元素，类型为正向迭代器
t.rend()      ------      返回set中第一个元素，类型为反向迭代器

t.find(k)      ------      寻找k，若找到返回对应的迭代器，否则返回end();
t.insert(a, b)      ------      插入指针[a, b)之间的元素，已有元素不会再次插入
t.erase(it)      ------      删除迭代器it对应的元素
t.erase(l, r)      ------      删除迭代器[l, r)之间的元素
lower_bound(k)      ------      返回第一个大于等于k的元素的迭代器
upper_bound(k)      ------      返回第一个大于k的元素的迭代器




———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
___________________________________________________________________________________________________________________

stack主要的方法:

pop
push
top
size
empty



———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
___________________________________________________________________________________________________________________


Lists将元素按顺序储存在链表中. 与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢.

assign() 给list赋值 
back() 返回最后一个元素 
begin() 返回指向第一个元素的迭代器 
clear() 删除所有元素 
empty() 如果list是空的则返回true 
end() 返回末尾的迭代器 
erase() 删除一个元素 
front() 返回第一个元素 
get_allocator() 返回list的配置器 
insert() 插入一个元素到list中 
max_size() 返回list能容纳的最大元素数量 
merge() 合并两个list 
pop_back() 删除最后一个元素 
pop_front() 删除第一个元素 
push_back() 在list的末尾添加一个元素 
push_front() 在list的头部添加一个元素 
rbegin() 返回指向第一个元素的逆向迭代器 
remove() 从list删除元素 
remove_if() 按指定条件删除元素 
rend() 指向list末尾的逆向迭代器 
resize() 改变list的大小 
reverse() 把list的元素倒转 
size() 返回list中的元素个数 
sort() 给list排序 
splice() 合并两个list 
swap() 交换两个list 
unique() 删除list中重复的元素


———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
___________________________________________________________________________________________________________________


queue的方法

queue 模板类的定义在<queue>头文件中。
与stack 模板类很相似，queue 模板类也需要两个模板参数，一个是元素类型，一个容器类
型，元素类型是必要的，容器类型是可选的，默认为deque 类型。
定义queue 对象的示例代码如下：
queue<int> q1;
queue<double> q2;

queue 的基本操作有：
入队，如例：q.push(x); 将x 接到队列的末端。
出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。
访问队首元素，如例：q.front()，即最早被压入队列的元素。
访问队尾元素，如例：q.back()，即最后被压入队列的元素。
判断队列空，如例：q.empty()，当队列空时，返回true。
访问队列中的元素个数，如例：q.size()


