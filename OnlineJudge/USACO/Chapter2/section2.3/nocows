DP题目没感觉= =参考题解

首先明确一下题目的意思：用N个点组成一棵深度为i的二叉树，求一共有几种方法？ 设dp[i,j]表示用i个点组成深度最多为j的二叉树的方法数，则：

dp[i,j]=∑(dp[k,j-1]×dp[i-1-k,j-1])(k in {1..i-2})
边界条件：dp[1,i]=1

我们要求的是深度恰好为K的方法数S，易知S=dp[n,k]-dp[n,k-1]。 但需要注意的是，如果每次都取模，最后可能会有dp[n,k]<dp[n,k-1],所以可以用S=(dp[n,k]-dp[n,k-1]+v) mod v

给出n,k,求满足以下条件的二叉树个数 1.每个结点的度为偶数 2.该树有n个结点 3.该树的深度为k 问题分析: 用动态规划和乘法原理求解,可以观察到一个树G(有x个结点,深度为k),如果去除它的根结点可以得到两个子数G1,G2,这两个子图的深度为k-1,他们的结点数的和为x-1.设其中G1有i个结点则G2有x-1-i个结点.

定义P(G)为与满足条件的二叉树G有同样多结点有深度相同且同样满足条件的树的个数.
将二叉树按上述方法依次分解为(有1个结点,深度为k-1的树和有x-1-1个结点深度为k-1的树),(有2个结点,深度为k-1的树和有x-1-2个结点深度为k-1的树),(有3个结点,深度为k-1的树和有x-1-3个结点深度为k-1的树)...(有x-1-1个结点,深度为k-1的树和有1个结点深度为k-1的树)...

由乘法原理得到:由G按上述方法分解成的每对二叉树(Gx,Gy)加一个根结点构成的二叉树的个数有P(Gx)*P(Gy)个.
G可以分解为x-2对子树,由加法原理得到P(G)=∑P(Gi)*P(Gj){(i,j)∈G可以分解到的子树对(Gi,Gj)}
定义f(x,k)满足为深度为k,结点个数为x,每个结点的度为偶数的二叉树的个数,由上述分析得到f(x,k)=∑(f(x-1-i,k-1)*f(i,k-1){1<=i<=x-2


代码：
/*
ID: scottn1
PROG: nocows
LANG: C++
*/
#include <bits/stdc++.h>
using namespace std;
#define T

int N, K;
int d[200][100];



int main()
{
    #ifdef T
        freopen("nocows.in", "r", stdin);
        freopen("nocows.out", "w", stdout);
    #endif

    cin >> N >> K;
    for(int i = 1; i <= K; i++)
        d[1][i] = 1;
    for(int j = 1; j <= K; j++)
    {
        for(int i = 3; i <= N; i+=2)
        {
            for(int k = 1; k < i-1; k+=2)
            {
                d[i][j] = (d[i][j]+d[k][j-1]*d[i-1-k][j-1])%9901;
            }
        }
    }
    cout << (d[N][K]-d[N][K-1]+9901)%9901 << endl;

    return 0;
}



