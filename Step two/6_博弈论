博弈论

附百度文库中的博弈论习题（有代码）：https://wenku.baidu.com/view/74ffdb44bb68a98271fefa57.html 

一．巴什博奕（Bash Game）：
首先我们来玩一个比较古老的报数游戏。A和B一起报数，每个人每次最少报一个,最多报4个。轮流报数,看谁先报到30.
如果不知道巴什博弈的可能会觉得这个是个有运气成分的问题，但是如果知道的人一定知道怎样一定可以赢。
比如A先报数的话,那么B一定可以赢(这里假定B知道怎么正确的报数)
B可以这样报数,每次报5-k(A)个数,其中k(A)是A报数的个数这样的话没一次
两人报完数之后会变成5 10 15 20 25 30这样是不是B一定会赢呢?是不是有一种被欺骗的感觉呢?好吧下面我们来看看这个原理。我们先看下一个一眼就能看出答案的例子 比如说我们报到5(4+1),每次报最多报4个,最少报1个.那么是不是后者一定可以赢呢？答案是肯定的。好了到这巴什博弈的精髓基本就OK了。
那么如果我们要报到n+1,每次最多报n个,最少报1个的话,后者一定能够赢。
现在我们需要报数到n,而每次最多报数m个,最少报数1个.我们可以化成这样
n = k*(1+m)+r(0 <= r <= m）这样的话如果r不等于0那么先手一定会赢，为什么呢？首先先手报r个,那么剩下k倍(1+m)个数,那么我们每次报数1+m-k(B)个数就一定能保证最后剩下1+m个,那么就到了上面我们说的那个了,先手就一定会赢,如果r=0那么后手一定会赢,道理一样的。
到这巴什博弈也就介绍完了,知道这个道理之后我们也可以去骗小朋友了。-_-//
代码如下：
[cpp] view plain copy
#include<iostream>  
#include<string>  
#include<cstring>  
#include<cstdio>  
#include<algorithm>  
#define CLR(arr, val) memset(arr, val, sizeof(arr))  
using namespace std;  
  
int main()  
{  
    //freopen("Input.txt", "r", stdin);  
    int N, num, limit;  
    scanf("%d", &N);  
    while(N--)  
    {  
        scanf("%d%d", &num, &limit);  
        if(num % (limit + 1) != 0) //必胜局面  
            printf("Win\n");  
        else  
            printf("Lose\n");  
    }  
    return 0;  
}          


二．威佐夫博奕（Wythoff Game）：
   这种博弈比前面一种要稍微复杂一点。我们来看下下面这个游戏。
   有两堆火柴棍,每次可以从某一堆取至少1根火柴棍(无上限)，或者从两堆取相同的火柴棍数。最后取完的是胜利者。好了,如果你不知道这个博弈定理,对于小数目的火柴棍数,可能还能推出来,但是如果火柴棍数一多,就不行了。看了下面的这个介绍,你也会有一种被骗的感觉。
   首先我们知道两堆火柴是没有差别的,也就是说第一堆有a根,第二堆有b根和第一堆有b根,第二堆有a根是一样的结果。
   我们用一个二维的状态（a,b)来记录当前剩下的火柴数，表示第一堆剩下a根火柴,第二堆剩下b根火柴。同样我们假设两个人的编号是A和B，且A先取。
那么如果某个人遇到了这样的状态(0,0)那么也就是说这个人输了。这样的状态我们叫做奇异状态,也可以叫做失败态。
那么接下来的几个失败态为(1,2),(3,5),(4,7),(6,10),(8,13)……
我们用a[i]表示失败态中的第一个,b[i]表示失败态中的第二个.(i从0开始).
那么我们可以看到b[i] = a[i]+i;（i >= 0）,a[i]是前面的失败态中没有出现过的最小的整数
下面我们可以得到三个基本的结论。
  1.每个数仅包含在一个失败态中
  首先我们知道a[k]是不可能和前面的失败态中的a[i],b[i]重复的(这点由a[i]的得到可以知道)
b[k] = a[k]+k > a[k-1]+k>a[k-1]+k-1+1>a[k-1]+(k-1) = b[k-1]>a[k-1]这样我们知道每个数仅在一个失败态中。
  2.每个失败态可以转到非失败态。
 加入当前的失败态为(a,b)，那么如果我们只在一堆中取的话,肯定会变成非失败态(这点由第一点可以保证),如果从两堆同时取的话,由于每个失败态的差是不一样的,所以也不可能得到一个失败态。也就是说一个失败态不管你怎么取,都会得到一个非失败态。
   3.每个非失败态都可以转到一个失败态
对于这个结论,首先我们要知到每个状态(a,b)要么a = a[i],要么b = b[i].(每个数都出现在一个失败态中),下面我们分两种情况来讨论
   I.a = a[i].如果b = a的话那么一次取完就变成了(0,0).如果b > b[i]的话,那么我们从第二堆中取走b-b[i]就变成了一个失败态。如果b < b[i].那么我们从两堆中同时取走a-a[b-a[i]]这样得到失败态(a[b-a[i]],a[b-a[i]]+b-a[i])(a[i] = a)
   II.b = b[i].如果a > a[i]那么我们从第一堆中取走a-a[i]根火柴.
              如果a < a[i].这里又分两种情况。第一是a = a[k](k < i)
那么我们从第二堆取走b - b[k]就行了。
第二是a = b[k]这样的话由于两堆火柴是没有区别的,所以我们把b变成a[k]就行了,也即是从第二堆火柴中取走b - a[k]就变成了失败态
至于怎么判断一个状态是否是失败态.我们可以用下面的方法来判断(本人暂时还不会证明)
  a[i] = [i*(1+√5)/2](这里的中括号表示向下取整)   b[i] = a[i]+i;
  那么这就是一个失败态
代码如下：
[cpp] view plain copy
#include<iostream>  
#include<string>  
#include<cstring>  
#include<cstdio>  
#include<cmath>  
#include<algorithm>  
#define CLR(arr, val) memset(arr, val, sizeof(arr))  
using namespace std;  
  
int main()  
{  
    //freopen("Input.txt", "r", stdin);  
    int num1, num2, tmp; //第一堆剩的数量为num1,第二堆剩num2  
    while(scanf("%d%d", &num1, &num2) != EOF)  
    {  
        if(num1 > num2)  
            swap(num1, num2);   
        tmp = floor((num2 - num1) * (1 + sqrt(5.0)) / 2.0); //黄金分割  
        if(tmp == num1) printf("Lose\n"); //奇异局势必败  
        else    printf("Win\n");  
    }  
    return 0;  
}          


三．尼姆博奕（Nimm Game）：
  
指的是这样的一个博弈游戏，目前有任意堆石子，每堆石子个数也是任意的，双方轮流从中取出石子，规则如下：
1)每一步应取走至少一枚石子；每一步只能从某一堆中取走部分或全部石子；
2)如果谁取到最后一枚石子就胜。
也就是尼姆博弈（Nimm Game）。
必败局面：也叫奇异局势。无论做出何出操作，最终结果都是输的局面。必败局面经过2次操作后，可以达到另一个必败局面。
必胜局面：经过1次操作后可以达到必败局面。
即当前局面不是必败局面就是必胜局面，而必胜局面可以一步转变成必败局面。
最终状态：
（1）最后剩下一堆石子；（必胜局面）
（2）剩下两堆，每堆一个；（必败局面）
（3）当石子剩下两堆，其中一堆只剩下1颗，另一堆剩下多于n颗石子时，当前取的人只需将多于1颗的那一堆取出n-1颗，则局面变为刚才提到的必败局面。（必胜局面）
判断当前局势是否为必胜（必败）局势：
1）把所有堆的石子数目用二进制数表示出来，当全部这些数按位异或结果为0时当前局面为必败局面，否则为必胜局面；
2）在必胜局面下，因为所有数按位异或的结果是大于零的，那么通过一次取，将这个（大于其它所有数按位异或的结果的）数下降到其它所有数按位异或的结果，这时局面就变为必败局面了。
定理：一组自然数中必然存在一个数，它大于等于其它所有数按位异或的结果。
证明：原命题等价于，设a1＾a2＾... ＾an=p，p≠0时，必存在k，使得ak＾p<ak（当p=0时，对于任意的k，有ak＾p=ak）。
设p的最高位是第q位，则至少存在一个k，使得ak的第q位也是1，而ak＾p的第q位为0，所以ak^p<ak
    补缀一点，（a＾b）＾b=a＾（b＾b）=a＾0=a，所以ak＾p相当于“其它所有数按位异或的结果”。
例1：2 45 45
45＾45＝0,45和45的异或等于0。
例 2：3 3 6 9
局势（3,6，9）因为3＾6＾9不等于0，所以这是一个必胜局势。
　3　011
＾6　110
　5　101　
即从第3堆中的9个中取走9－5＝4个，则（3,6，9）－＞（3,6，5），3＾6＾5＝0，故（3,6，5）为奇异局势，即从必胜局势转变成必败局势。
代码如下：
[cpp] view plain copy
#include<iostream>  
using namespace std;  
int temp[ 20 ]; //火柴的堆数  
  
int main()  
{  
    int i, n, min;  
    while( cin >> n )  
    {  
        for( i = 0; i < n; i++ )  
            cin >> temp[ i ]; //第i个火柴堆的数量  
        min = temp[ 0 ];  
        for( i = 1; i < n ; i++ )  
            min = min^temp[ i ]; //按位异或  
        if( min == 0 )  
            cout << "Lose" << endl; //输  
        else  
            cout << "Win" << endl; //赢  
    }  
    return 0;  
}  